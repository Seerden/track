import { timestampSchema } from "../../lib/schemas/timestamp";
import type {
	Datelike,
	ID,
	Nullable,
	NullUnused,
	Timestamp,
} from "./utility.types";

type ActivityTimestamps = {
	started_at: Timestamp; // TODO: should become start_timestamp
	ended_at: Timestamp; // TODO: should become end_timestamp
};

type ActivityDates = {
	start_date: Datelike;
	end_date: Datelike;
};

/** An activity without autogenerated fields or tag/(sub)category ids. */
export type NewActivityBase = {
	user_id: ID;
	name: string;
	description: string;
	duration_milliseconds?: number;
	is_task?: boolean;
};

export type WithTimestamps = NullUnused<ActivityTimestamps, ActivityDates>;
export type WithDates = NullUnused<ActivityDates, ActivityTimestamps>;

export type TaskUpdate = {
	completion_start?: Timestamp;
	completion_end?: Timestamp;
	completed?: Nullable<boolean>;
};

export type ActivityInput = {
	activity: NewActivity;
	tagIds?: ID[];
};

import { z } from "zod";

const newActivityBaseSchema = z.object({
	user_id: z.string(),
	name: z.string(),
	description: z.string(),
	duration_milliseconds: z.number().optional(),
	is_task: z.boolean().optional(),
});

const activityWithTimestampsSchema = newActivityBaseSchema.merge(
	z.object({
		started_at: timestampSchema,
		ended_at: timestampSchema,
		start_date: z.null(),
		end_date: z.null(),
	}),
);

const activityWithDatesSchema = newActivityBaseSchema.merge(
	z.object({
		started_at: z.null(),
		ended_at: z.null(),
		start_date: timestampSchema,
		end_date: timestampSchema,
	}),
);

export type ActivityWithDates = z.infer<typeof activityWithDatesSchema>;
export type ActivityWithTimestamps = z.infer<
	typeof activityWithTimestampsSchema
>;

const activityOccurrenceBaseSchema = z.union([
	z.object({
		occurrence: z.null(),
		recurrence_id: z.null(),
	}),
	z.object({
		occurrence: z.number(),
		recurrence_id: z.string(),
	}),
]);

export type ActivityOccurrenceBase = z.infer<
	typeof activityOccurrenceBaseSchema
>;

// NewActivity
export const newActivitySchema = z.intersection(
	z.union([activityWithTimestampsSchema, activityWithDatesSchema]),
	activityOccurrenceBaseSchema,
);

export type NewActivity = z.infer<typeof newActivitySchema>;

export const taskUpdateSchema = z.object({
	completion_start: timestampSchema.nullable().optional(),
	completion_end: timestampSchema.nullable().optional(),
	completed: z.boolean().nullable().optional(),
});

/** includes autogenerated fields */
export const activityBaseSchema = z.object({
	activity_id: z.string(),
	created_at: timestampSchema,
});

export type ActivityBase = z.infer<typeof activityBaseSchema>;

export const activitySchema = newActivitySchema
	.and(taskUpdateSchema)
	.and(activityBaseSchema);

export type Activity = z.infer<typeof activitySchema>;

export const activityWithIdsSchema = activitySchema.and(
	z.object({
		tag_ids: z.array(z.string()),
	}),
);

export type ActivityWithIds = z.infer<typeof activityWithIdsSchema>;

export const taskUpdateInputSchema = z.intersection(
	taskUpdateSchema,
	activityBaseSchema.pick({ activity_id: true }),
);

export type TaskUpdateInput = z.infer<typeof taskUpdateInputSchema>;

export const activityUpdateInputSchema = z.object({
	activity: activityWithIdsSchema,
	tag_ids: z.array(z.string()),
});

export type ActivityUpdateInput = z.infer<typeof activityUpdateInputSchema>;
