import { intervalUnitSchema } from "@shared/lib/schemas/habit";
import { timestampSchema } from "@shared/lib/schemas/timestamp";
import { z } from "@shared/lib/zod";
import { dayOfWeekSchema } from "@shared/types/data/utility.types";
import { userSchema } from "./user";

export const recurrenceIntervalBaseSchema = z.union([
	z.object({
		frequency: z.literal("numeric"),
		interval_unit: intervalUnitSchema,
		weekdays: z.null(),
		monthdays: z.null(),
	}),
	z.object({
		frequency: z.literal("calendar"),
		interval_unit: z.literal("week"),
		weekdays: z.array(dayOfWeekSchema),
		monthdays: z.null(),
	}),
	z.object({
		frequency: z.literal("calendar"),
		interval_unit: z.literal("month"),
		weekdays: z.null(),
		monthdays: z.array(z.number()),
	}),
]);

export const newRecurrenceInputSchema = z
	.object({
		interval: z.number(),
		start_timestamp: timestampSchema,
		end_timestamp: timestampSchema.nullable(),
	})
	.and(recurrenceIntervalBaseSchema);
export type NewRecurrenceInput = z.infer<typeof newRecurrenceInputSchema>;

/**
 * @note by including activity_id, we're directly associating this type with
 * business logic. */
export const createRecurrenceInputSchema = newRecurrenceInputSchema.and(
	z.object({
		/** from ActivityWithIds["activity_id"] */
		activity_id: z.string(),
	}),
);
export type CreateRecurrenceInput = z.infer<typeof createRecurrenceInputSchema>;

export const newRecurrenceSchema = newRecurrenceInputSchema.and(
	z.object({
		user_id: z.string(),
	}),
);
export type NewRecurrence = z.infer<typeof newRecurrenceSchema>;

export const recurrenceSchema = newRecurrenceSchema.and(
	z.object({
		recurrence_id: z.string(),
		created_at: timestampSchema,
	}),
);
export type Recurrence = z.infer<typeof recurrenceSchema>;

export const recurrenceWithIdsSchema = recurrenceSchema.and(
	z.object({
		activity_id: z.string(),
	}),
);
export type RecurrenceWithIds = z.infer<typeof recurrenceWithIdsSchema>;

export const occurrenceDivergenceBaseSchema = z.discriminatedUnion(
	"divergence_kind",
	[
		z.object({
			divergence_kind: z.literal("offset"),
			offset_milliseconds: z.string(), // TODO: bigint
		}),
		z.object({
			divergence_kind: z.literal("skip"),
			offset_milliseconds: z.null(),
		}),
	],
);
export type OccurrenceDivergenceBase = z.infer<
	typeof occurrenceDivergenceBaseSchema
>;

export const newOccurrenceInputSchema = occurrenceDivergenceBaseSchema.and(
	z.object({
		recurrence_id: z.string(),
		activity_id: z.string(),
		divergence_count: z.number(),
		excluded_activity_ids: z.array(z.string()),
	}),
);
export type NewOccurrenceInput = z.infer<typeof newOccurrenceInputSchema>;

export const newOccurrenceSchema = newOccurrenceInputSchema.and(
	z.object({
		user_id: z.string(),
	}),
);
export type NewOccurrence = z.infer<typeof newOccurrenceSchema>;

export const occurrenceSchema = newOccurrenceSchema.and(
	z.object({
		occurrence_id: z.string(),
	}),
);
export type Occurrence = z.infer<typeof occurrenceSchema>;

/** An activity without autogenerated fields or tag/(sub)category ids. */
export const newActivityBaseSchema = z.object({
	name: z
		.string()
		.min(1, "Activity needs a name")
		.max(64, "Activity name can contain at most 64 characters"),
	description: z.string().nullable(),
	duration_milliseconds: z.number().nullable().optional().default(null),
	is_task: z.boolean().optional().default(false),
	will_recur: z.boolean().nullable().optional().default(false),
	/** This is really just there for when we want to turn a synthetic activity
	 * into a real one through `putCompletion`. Regular new activities will
	 * always start with falsy `completed`. */
	completed: z.boolean().nullable().optional().default(false),
});
export type NewActivityBase = z.infer<typeof newActivityBaseSchema>;

export const withDatesBaseSchema = z.object({
	started_at: z.null(),
	ended_at: z.null(),
	start_date: timestampSchema,
	end_date: timestampSchema,
});

export type WithDates = z.infer<typeof withDatesBaseSchema>;

export const withTimestampsBaseSchema = z.object({
	started_at: timestampSchema,
	ended_at: timestampSchema,
	start_date: z.null(),
	end_date: z.null(),
});

export const activityWithTimestampsSchema = newActivityBaseSchema.merge(
	withTimestampsBaseSchema,
);
export type WithTimestamps = z.infer<typeof withTimestampsBaseSchema>;

export type ActivityWithTimestamps = z.infer<
	typeof activityWithTimestampsSchema
>;

export const activityWithDatesSchema =
	newActivityBaseSchema.merge(withDatesBaseSchema);
export type ActivityWithDates = z.infer<typeof activityWithDatesSchema>;

export const activityOccurrenceBaseSchema = z.union([
	z.object({
		occurrence: z.null(),
		recurrence_id: z.null(),
	}),
	z.object({
		/** @note only recurring instances have an `occurrence` number. The
		 * original activity does not. */
		occurrence: z.number().nullable(),
		recurrence_id: z.string(),
	}),
]);
export type ActivityOccurrenceBase = z.infer<
	typeof activityOccurrenceBaseSchema
>;

/** This is the client-side created new activity. */
export const newActivityInputSchema = activityOccurrenceBaseSchema.and(
	z.union([activityWithTimestampsSchema, activityWithDatesSchema]),
);
export type NewActivityInput = z.infer<typeof newActivityInputSchema>;

/** The server will append the user_id to NewActivityInput before inserting the
 * activity into the database. */
export const newActivitySchema = newActivityInputSchema.and(
	z.object({
		user_id: userSchema.shape.user_id,
	}),
);

export type NewActivity = z.infer<typeof newActivitySchema>;

export const activityInputSchema = z.object({
	activity: newActivityInputSchema,
	tagIds: z.array(z.string()).optional(),
});
export type ActivityInput = z.infer<typeof activityInputSchema>;

export const recurringActivityInputSchema = activityInputSchema.and(
	z.object({
		recurrence: newRecurrenceInputSchema,
	}),
);

export const taskUpdateSchema = z.object({
	completion_start: timestampSchema.nullable().optional(),
	completion_end: timestampSchema.nullable().optional(),
	completed: z.boolean().nullable().optional(),
});
export type TaskUpdate = z.infer<typeof taskUpdateSchema>;

/** includes autogenerated fields */
export const activityBaseSchema = z.object({
	activity_id: z.string(),
	created_at: timestampSchema,
});

export const activitySchema = newActivitySchema
	.and(taskUpdateSchema)
	.and(activityBaseSchema);
export type Activity = z.infer<typeof activitySchema>;

const syntheticActivityBaseSchema = activityBaseSchema
	.omit({ activity_id: true })
	.and(z.object({ activity_id: z.null().optional() }));
const syntheticActivityWithoutIdsSchema = newActivitySchema
	.and(taskUpdateSchema)
	.and(syntheticActivityBaseSchema);
export const syntheticActivitySchema = syntheticActivityWithoutIdsSchema
	.and(
		z.object({
			tag_ids: z.array(z.string()),
		}),
	)
	.and(
		z.object({
			synthetic: z.literal(true),
			synthetic_id: z.string(),
		}),
	);

export type SyntheticActivity = z.infer<typeof syntheticActivitySchema>;

export const activityWithIdsSchema = activitySchema.and(
	z.object({
		tag_ids: z.array(z.string()),
	}),
);
export type ActivityWithIds = z.infer<typeof activityWithIdsSchema>;

export const activityUpdateInputSchema = z.object({
	activity: activityWithIdsSchema,
	tag_ids: z.array(z.string()),
});

export type ActivityUpdateInput = z.infer<typeof activityUpdateInputSchema>;

export type ActivityBase = z.infer<typeof activityBaseSchema>;

export const taskUpdateInputSchema = z.intersection(
	taskUpdateSchema,
	activityBaseSchema.pick({ activity_id: true }),
);

export type TaskUpdateInput = z.infer<typeof taskUpdateInputSchema>;

/**
 * @note client only, since the concept of a synthetic activity lives only in
 * the client. Should probably move it to the client, too.
 */
export type PossiblySyntheticActivity = ActivityWithIds | SyntheticActivity;
