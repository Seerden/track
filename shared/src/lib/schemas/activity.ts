import { intervalUnitSchema } from "@shared/lib/schemas/habit";
import { timestampSchema } from "@shared/lib/schemas/timestamp";
import { z } from "@shared/lib/zod";
import { dayOfWeekSchema } from "@shared/types/data/utility.types";

export const recurrenceIntervalBaseSchema = z.union([
	z.object({
		frequency: z.literal("numeric"),
		interval_unit: intervalUnitSchema,
		weekdays: z.null(),
		monthdays: z.null(),
	}),
	z.object({
		frequency: z.literal("calendar"),
		interval_unit: z.literal("week"),
		weekdays: z.array(dayOfWeekSchema),
		monthdays: z.null(),
	}),
	z.object({
		frequency: z.literal("calendar"),
		interval_unit: z.literal("month"),
		weekdays: z.null(),
		monthdays: z.array(z.number()),
	}),
]);

export const newRecurrenceInputSchema = z
	.object({
		interval: z.number(),
		start_timestamp: timestampSchema,
		end_timestamp: timestampSchema.nullable(),
	})
	.and(recurrenceIntervalBaseSchema);
export type NewRecurrenceInput = z.infer<typeof newRecurrenceInputSchema>;

/**
 * @note by including activity_id, we're directly associating this type with
 * business logic. */
export const createRecurrenceInputSchema = newRecurrenceInputSchema.and(
	z.object({
		/** from ActivityWithIds["activity_id"] */
		activity_id: z.string(),
	}),
);
export type CreateRecurrenceInput = z.infer<typeof createRecurrenceInputSchema>;

export const newRecurrenceSchema = newRecurrenceInputSchema.and(
	z.object({
		user_id: z.string(),
	}),
);
export type NewRecurrence = z.infer<typeof newRecurrenceSchema>;

export const recurrenceSchema = newRecurrenceSchema.and(
	z.object({
		recurrence_id: z.string(),
		created_at: timestampSchema,
	}),
);
export type Recurrence = z.infer<typeof recurrenceSchema>;

export const recurrenceWithIdsSchema = recurrenceSchema.and(
	z.object({
		activity_id: z.string(),
	}),
);
export type RecurrenceWithIds = z.infer<typeof recurrenceWithIdsSchema>;

export const occurrenceDivergenceBaseSchema = z.discriminatedUnion(
	"divergence_kind",
	[
		z.object({
			divergence_kind: z.literal("offset"),
			offset_milliseconds: z.string(), // TODO: bigint
		}),
		z.object({
			divergence_kind: z.literal("skip"),
			offset_milliseconds: z.null(),
		}),
	],
);
export type OccurrenceDivergenceBase = z.infer<
	typeof occurrenceDivergenceBaseSchema
>;

export const newOccurrenceInputSchema = occurrenceDivergenceBaseSchema.and(
	z.object({
		recurrence_id: z.string(),
		activity_id: z.string(),
		divergence_count: z.number(),
		excluded_activity_ids: z.array(z.string()),
	}),
);
export type NewOccurrenceInput = z.infer<typeof newOccurrenceInputSchema>;

export const newOccurrenceSchema = newOccurrenceInputSchema.and(
	z.object({
		user_id: z.string(),
	}),
);
export type NewOccurrence = z.infer<typeof newOccurrenceSchema>;

export const occurrenceSchema = newOccurrenceSchema.and(
	z.object({
		occurrence_id: z.string(),
	}),
);
export type Occurrence = z.infer<typeof occurrenceSchema>;

/** An activity without autogenerated fields or tag/(sub)category ids. */
export const newActivityBaseSchema = z.object({
	user_id: z.string(),
	name: z.string(),
	description: z.string(),
	duration_milliseconds: z.number().nullable().optional().default(null),
	is_task: z.boolean().optional().default(false),
	will_recur: z.boolean().nullable().optional().default(false),
});
export type NewActivityBase = z.infer<typeof newActivityBaseSchema>;

export const withDatesBaseSchema = z.object({
	started_at: z.null(),
	ended_at: z.null(),
	start_date: timestampSchema,
	end_date: timestampSchema,
});

export type WithDates = z.infer<typeof withDatesBaseSchema>;

export const withTimestampsBaseSchema = z.object({
	started_at: timestampSchema,
	ended_at: timestampSchema,
	start_date: z.null(),
	end_date: z.null(),
});

export const activityWithTimestampsSchema = newActivityBaseSchema.merge(
	withTimestampsBaseSchema,
);
export type WithTimestamps = z.infer<typeof withTimestampsBaseSchema>;

export type ActivityWithTimestamps = z.infer<
	typeof activityWithTimestampsSchema
>;

export const activityWithDatesSchema =
	newActivityBaseSchema.merge(withDatesBaseSchema);
export type ActivityWithDates = z.infer<typeof activityWithDatesSchema>;

export const activityOccurrenceBaseSchema = z.union([
	z.object({
		occurrence: z.null(),
		recurrence_id: z.null(),
	}),
	z.object({
		/** @note only recurring instances have an `occurrence` number. The
		 * original activity does not. */
		occurrence: z.number().nullable(),
		recurrence_id: z.string(),
	}),
]);
export type ActivityOccurrenceBase = z.infer<
	typeof activityOccurrenceBaseSchema
>;

export const newActivitySchema = activityOccurrenceBaseSchema.and(
	z.union([activityWithTimestampsSchema, activityWithDatesSchema]),
);

export type NewActivity = z.infer<typeof newActivitySchema>;

export const activityInputSchema = z.object({
	activity: newActivitySchema,
	tagIds: z.array(z.string()).optional(),
});
export type ActivityInput = z.infer<typeof activityInputSchema>;

export const recurringActivityInputSchema = activityInputSchema.and(
	z.object({
		recurrence: newRecurrenceInputSchema,
	}),
);

export const taskUpdateSchema = z.object({
	completion_start: timestampSchema.nullable().optional(),
	completion_end: timestampSchema.nullable().optional(),
	completed: z.boolean().nullable().optional(),
});
export type TaskUpdate = z.infer<typeof taskUpdateSchema>;

/** includes autogenerated fields */
export const activityBaseSchema = z.object({
	activity_id: z.string(),
	created_at: timestampSchema,
});

export const activitySchema = newActivitySchema
	.and(taskUpdateSchema)
	.and(activityBaseSchema);
export type Activity = z.infer<typeof activitySchema>;

export const activityWithIdsSchema = activitySchema.and(
	z.object({
		tag_ids: z.array(z.string()),
	}),
);
export type ActivityWithIds = z.infer<typeof activityWithIdsSchema>;

export const activityUpdateInputSchema = z.object({
	activity: activityWithIdsSchema,
	tag_ids: z.array(z.string()),
});

export type ActivityUpdateInput = z.infer<typeof activityUpdateInputSchema>;

export type ActivityBase = z.infer<typeof activityBaseSchema>;

export const taskUpdateInputSchema = z.intersection(
	taskUpdateSchema,
	activityBaseSchema.pick({ activity_id: true }),
);

export type TaskUpdateInput = z.infer<typeof taskUpdateInputSchema>;

// TODO TRK-206: this needs some work
export const syntheticActivitySchema = activityWithIdsSchema
	.and(
		z.object({
			synthetic: z.literal(true),
			synthetic_id: z.string(),
		}),
	)
	// TODO: synthetic activities should not have an ID. It should be
	// appended to the activity on submission (i.e. when it becomes
	// non-synthetic). Check how I did this for habits.
	.transform((activity) => ({ ...activity, activity_id: null }));
export type SyntheticActivity = z.infer<typeof syntheticActivitySchema>;
